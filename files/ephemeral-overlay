#!/bin/bash

set -e

if [ -r /usr/lib/libmimalloc.so ]; then
    RSYNC="env LD_PRELOAD=/usr/lib/libmimalloc.so rsync"
    FIND="env LD_PRELOAD=/usr/lib/libmimalloc.so find"
    LSOF="env LD_PRELOAD=/usr/lib/libmimalloc.so lsof"
else
    RSYNC="rsync"
    FIND="find"
    LSOF="lsof"
fi

OVERLAY_BASE="/ram_overlay"
UPPERDIR="$OVERLAY_BASE/upper"
WORKDIR="$OVERLAY_BASE/work"
MERGED="/overlay_merged"
STATE_FILE="/var/run/ramoverlay.state"
DAEMON_PIDFILE="/var/run/ramoverlay-daemon.pid"
LOG_FILE="/var/log/ramoverlay.log"

TMP_SIZE="5G"
VAR_TMP_SIZE="1G"
VAR_CACHE_SIZE="2G"
USER_CACHE_SIZE="2G"

CLEAN_INTERVAL=60
STALE_MINUTES=10

PERSIST_ROOT="/persist"

BIND_MOUNTED_VAR_CACHE=(pacman)
BIND_MOUNTED_USER_CACHE=(paru nvidia mesa_shader_cache mesa_shader_cache_db)

EXCLUDED_DIRS=(
    "/home"
    "/tmp"
    "/var/tmp"
    "/var/cache"
    "/proc"
    "/sys"
    "/dev"
    "/run"
    "/mnt"
    "/media"
    "/boot"
)

USE_LSOF=0
USE_FUSER=0
if command -v lsof >/dev/null 2>&1; then
    USE_LSOF=1
elif command -v fuser >/dev/null 2>&1; then
    USE_FUSER=1
fi

timestamp() { date +"%Y-%m-%dT%H:%M:%S%z"; }

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        log "ERROR: Must be run as root"
        exit 1
    fi
}

is_active() {
    [ -f "$STATE_FILE" ] && grep -q "active" "$STATE_FILE"
}

is_file_in_use() {
    local file="$1"
    [ -e "$file" ] || return 1
    if [ "$USE_LSOF" -eq 1 ]; then
        $LSOF -t -- "$file" >/dev/null 2>&1 && return 0 || return 1
    elif [ "$USE_FUSER" -eq 1 ]; then
        fuser -s -- "$file" >/dev/null 2>&1 && return 0 || return 1
    else
        local t
        t="$(readlink -f -- "$file")" || return 1
        for fd in /proc/[0-9]*/fd/*; do
            [ -e "$fd" ] || continue
            local link
            link="$(readlink -f -- "$fd" 2>/dev/null)" || continue
            [ "$link" = "$t" ] && return 0
        done
    fi
    return 1
}

mount_tmpfs() {
    local dir="$1" size="$2" mode="$3"
    mkdir -p -- "$dir"
    if mountpoint -q -- "$dir"; then
        log "$dir already mounted, skipping."
        return 0
    fi
    log "Mounting tmpfs on $dir (size=$size mode=$mode)..."
    mount -t tmpfs -o "size=${size},mode=${mode}" none "$dir"
}

bind_persistent_dirs() {
    local parent="$1"
    shift
    local dirs=("$@")
    local persist_root="${PERSIST_ROOT}${parent}"
    mkdir -p "$persist_root" || { log "ERROR: failed to mkdir $persist_root"; return 1; }

    for d in "${dirs[@]}"; do
        local src="$persist_root/$d"
        local dest="$parent/$d"

        if [ -d "$dest" ] && [ ! -e "$src" ]; then
            mkdir -p "$(dirname "$src")"
            if [ "$(ls -A "$dest" 2>/dev/null || true)" != "" ]; then
                log "Moving existing $dest -> $src (first-run persistence)"
                if command -v rsync >/dev/null 2>&1; then
                    $RSYNC -a --remove-source-files "$dest"/ "$src"/ || true
                    $FIND "$dest" -mindepth 1 -type d -empty -delete || true
                else
                    mv "$dest" "$src" || true
                fi
            fi
        fi

        mkdir -p "$src" "$dest"
        
        if ! mountpoint -q "$dest"; then
            mount --bind "$src" "$dest"
            log "Bind-mounted $src -> $dest"
        else
            log "$dest already a mountpoint, skipping bind."
        fi
    done
}

mount_user_caches() {
    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $1 ":" $6 }')
    while IFS=: read -r username homedir; do
        [ -n "$username" ] && [ -n "$homedir" ] || continue
        [ -d "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        local user_stat
        user_stat=$(stat -c "%u:%g" "$homedir" 2>/dev/null) || continue
        local uid=${user_stat%:*}
        local gid=${user_stat#*:}

        if [ ! -d "$cache_dir" ]; then
            mkdir -p "$cache_dir"
            chown "${uid}:${gid}" "$cache_dir"
            chmod 0700 "$cache_dir"
        fi

        if mountpoint -q -- "$cache_dir"; then
            log "$cache_dir already mounted, skipping."
            continue
        fi

        log "Mounting tmpfs on $cache_dir (size=$USER_CACHE_SIZE) for $username..."
        mount -t tmpfs -o "size=${USER_CACHE_SIZE},mode=0700,uid=${uid},gid=${gid}" none "$cache_dir"
        
        bind_persistent_dirs "$cache_dir" "${BIND_MOUNTED_USER_CACHE[@]}"
        
        chown "${uid}:${gid}" "$cache_dir" || true
        for subdir in "${BIND_MOUNTED_USER_CACHE[@]}"; do
            if [ -d "$cache_dir/$subdir" ]; then
                chown -R "${uid}:${gid}" "$cache_dir/$subdir" || true
            fi
        done
    done <<< "$users"
}

umount_try() {
    local dir="$1"
    [ ! -d "$dir" ] && return 0
    if ! mountpoint -q -- "$dir"; then return 0; fi

    log "Attempting normal umount $dir..."
    if umount "$dir" 2>/dev/null; then log "Unmounted $dir (normal)"; return 0; fi
    log "Normal umount failed; trying force..."
    if umount -f "$dir" 2>/dev/null; then log "Unmounted $dir (force)"; return 0; fi
    log "Force umount failed; trying lazy..."
    if umount -l "$dir" 2>/dev/null; then log "Unmounted $dir (lazy)"; return 0; fi
    log "All umount attempts failed for $dir."
    return 1
}

umount_user_caches() {
    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $6 }')
    while read -r homedir; do
        [ -n "$homedir" ] && [ -d "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        for ((i=${#BIND_MOUNTED_USER_CACHE[@]}-1; i>=0; i--)); do
            umount_try "$cache_dir/${BIND_MOUNTED_USER_CACHE[i]}" || true
        done
        umount_try "$cache_dir" || true
    done <<< "$users"
}

umount_var_cache() {
    for ((i=${#BIND_MOUNTED_VAR_CACHE[@]}-1; i>=0; i--)); do
        umount_try "/var/cache/${BIND_MOUNTED_VAR_CACHE[i]}" || true
    done
    umount_try /var/cache || true
}

cleanup_stale_files() {
    local var_cache_excludes=()
    for dir in "${BIND_MOUNTED_VAR_CACHE[@]}"; do
        var_cache_excludes+=("/var/cache/$dir")
    done

    for dir in /tmp /var/tmp; do
        [ -d "$dir" ] || continue
        $FIND "$dir" -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            is_file_in_use "$file" && log "Skipping in-use file: $file" || (rm -rf -- "$file" && log "Removed stale: $file")
        done
    done

    if [ -d /var/cache ]; then
        $FIND /var/cache -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            for ex in "${var_cache_excludes[@]}"; do
                [[ "$file" == "$ex"* ]] && continue 2
            done
            is_file_in_use "$file" && log "Skipping in-use cache file: $file" || (rm -rf -- "$file" && log "Removed stale cache: $file")
        done
    fi

    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $6 }')
    while read -r homedir; do
        [ -n "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        [ -d "$cache_dir" ] || continue
        $FIND "$cache_dir" -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            for ex in "${BIND_MOUNTED_USER_CACHE[@]}"; do
                [[ "$file" == "$cache_dir/$ex"* ]] && continue 2
            done
            is_file_in_use "$file" && log "Skipping in-use user cache file: $file" || (rm -rf -- "$file" && log "Removed stale user cache: $file")
        done
    done <<< "$users"
}

start_tmpfs_mounts() {
    log "Starting tmpfs mounts for temporary directories..."
    
    mkdir -p "$PERSIST_ROOT"
    
    mount_tmpfs /tmp "$TMP_SIZE" 1777
    mount_tmpfs /var/tmp "$VAR_TMP_SIZE" 1777
    mount_tmpfs /var/cache "$VAR_CACHE_SIZE" 0755

    bind_persistent_dirs /var/cache "${BIND_MOUNTED_VAR_CACHE[@]}"
    mount_user_caches

    getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $1 ":" $6 }' | \
    while IFS=: read -r username homedir; do
        [ -d "$homedir" ] || continue
        if [ -d "$homedir/.cache" ]; then
            uidgid=$(stat -c "%u:%g" "$homedir")
            chown "$uidgid" "$homedir/.cache" || true
            chmod 0700 "$homedir/.cache" || true
            log "Fixed perms for $homedir/.cache"
        fi
    done
    
    log "tmpfs mounts completed."
}

stop_tmpfs_mounts() {
    log "Stopping tmpfs mounts..."
    log "Syncing filesystem..."
    sync
    
    umount_user_caches
    umount_var_cache
    umount_try /var/tmp || true
    umount_try /tmp || true
    
    log "tmpfs mounts stopped."
}

get_available_ram() {
    local total_kb=$(awk '/MemTotal/ {print int($2 * 0.9)}' /proc/meminfo)
    local total_mb=$((total_kb / 1024))
    echo "${total_mb}M"
}

create_overlay_dirs() {
    log "Creating RAM overlay directories..."
    
    local ram_size=$(get_available_ram)
    log "Detected total RAM allocation: $ram_size (90% of total memory)"
    
    mkdir -p "$OVERLAY_BASE"
    
    if ! mountpoint -q "$OVERLAY_BASE"; then
        mount -t tmpfs -o size=$ram_size,mode=0755 tmpfs "$OVERLAY_BASE" || \
            { log "ERROR: Failed to mount tmpfs at $OVERLAY_BASE"; return 1; }
    fi
    
    mkdir -p "$UPPERDIR" "$WORKDIR" "$MERGED"
    
    for dir in "${EXCLUDED_DIRS[@]}"; do
        mkdir -p "$UPPERDIR$dir"
    done
}

start_overlay() {
    if is_active; then
        log "RAM overlay is already active"
        return 0
    fi
    
    log "Starting unified RAM overlay system..."
    
    start_tmpfs_mounts
    create_overlay_dirs
    
    LOWERDIR="/"
    
    log "Mounting overlay filesystem..."
    mount -t overlay overlay \
        -o lowerdir=$LOWERDIR,upperdir=$UPPERDIR,workdir=$WORKDIR \
        "$MERGED" || { log "ERROR: Failed to mount overlay"; return 1; }
    
    for dir in "${EXCLUDED_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            mkdir -p "$MERGED$dir"
            mount --bind "$dir" "$MERGED$dir" 2>/dev/null || true
        fi
    done
    
    echo "active" > "$STATE_FILE"
    echo "started=$(date +%s)" >> "$STATE_FILE"
    
    log "RAM overlay system started successfully"
    log "Overlay mounted at: $MERGED"
    log "Changes are being stored in RAM at: $UPPERDIR"
    
    df -h "$OVERLAY_BASE" 2>/dev/null | tail -1 | awk '{print "RAM allocated: " $2 " (Available: " $4 ")"}'
    
    log "tmpfs cleanup loop starting (interval=${CLEAN_INTERVAL}s, stale>${STALE_MINUTES}m)."
}

sync_changes() {
    if ! is_active; then
        log "RAM overlay is not active, nothing to sync"
        return 0
    fi
    
    log "Syncing changes from RAM to disk..."
    
    $RSYNC -aAXHv \
        --exclude='/home/*' \
        --exclude='/tmp/*' \
        --exclude='/var/tmp/*' \
        --exclude='/var/cache/*' \
        --exclude='/proc/*' \
        --exclude='/sys/*' \
        --exclude='/dev/*' \
        --exclude='/run/*' \
        "$UPPERDIR/" "/" 2>&1 | tee -a "$LOG_FILE"
    
    sync
    log "Sync completed successfully"
}

stop_overlay() {
    if ! is_active; then
        log "RAM overlay is not active"
        stop_tmpfs_mounts
        return 0
    fi
    
    log "Stopping RAM overlay system..."
    
    sync_changes
    
    for dir in "${EXCLUDED_DIRS[@]}"; do
        if mountpoint -q "$MERGED$dir" 2>/dev/null; then
            umount "$MERGED$dir" 2>/dev/null || true
        fi
    done
    
    if mountpoint -q "$MERGED"; then
        log "Unmounting overlay filesystem..."
        umount "$MERGED" || log "Warning: Failed to unmount overlay"
    fi
    
    if mountpoint -q "$OVERLAY_BASE"; then
        log "Unmounting tmpfs and freeing RAM..."
        umount "$OVERLAY_BASE" || log "Warning: Failed to unmount tmpfs"
    fi
    
    rmdir "$MERGED" 2>/dev/null || true
    rm -f "$STATE_FILE"
    
    stop_tmpfs_mounts
    
    log "RAM overlay system stopped - RAM freed"
}

get_logged_in_users() {
    who | awk '{print $1}' | sort -u | wc -l
}

wait_for_login() {
    log "Waiting for user login..."
    
    while true; do
        local users=$(get_logged_in_users)
        
        if [ "$users" -gt 0 ]; then
            log "User login detected ($users users)"
            return 0
        fi
        
        sleep 5
    done
}

shutdown_cleanup() {
    log "Shutdown/reboot signal received - syncing all changes to disk..."
    sync_changes
    stop_overlay
    rm -f "$DAEMON_PIDFILE"
    log "Shutdown sync complete - exiting"
    exit 0
}

check_root

if [ -f "$DAEMON_PIDFILE" ] && kill -0 $(cat "$DAEMON_PIDFILE") 2>/dev/null; then
    log "Already running with PID $(cat $DAEMON_PIDFILE) - exiting"
    exit 0
fi

echo $$ > "$DAEMON_PIDFILE"

mkdir -p "$(dirname "$LOG_FILE")"
touch "$LOG_FILE" || true

log "Unified RAM overlay daemon started (PID: $$)"
[ "$USE_LSOF" -eq 1 ] && log "Using lsof to detect open files" || log "Using fuser or /proc fallback for file detection"

trap shutdown_cleanup SIGTERM SIGINT SIGHUP

while true; do
    wait_for_login
    
    sleep 3
    
    log "Starting RAM overlay system..."
    start_overlay
    
    if [ $? -eq 0 ]; then
        log "RAM overlay started successfully"
    else
        log "ERROR: Failed to start RAM overlay - will retry on next login"
        sleep 5
        continue
    fi
    
    while [ $(get_logged_in_users) -gt 0 ]; do
        sleep "$CLEAN_INTERVAL"
        cleanup_stale_files
    done
    
    log "All users logged out - initiating shutdown sequence"
    
    sleep 2
    
    log "Stopping and syncing RAM overlay..."
    stop_overlay
    
    if [ $? -eq 0 ]; then
        log "RAM overlay stopped and synced successfully"
    else
        log "ERROR: Issues during RAM overlay shutdown"
    fi
    
    log "System ready for next login cycle"
    
    sleep 5
done
