#!/bin/bash

set -e

if [ -r /usr/lib/libmimalloc.so ]; then
    RSYNC="env LD_PRELOAD=/usr/lib/libmimalloc.so rsync"
    FIND="env LD_PRELOAD=/usr/lib/libmimalloc.so find"
    LSOF="env LD_PRELOAD=/usr/lib/libmimalloc.so lsof"
else
    RSYNC="rsync"
    FIND="find"
    LSOF="lsof"
fi

OVERLAY_BASE="/ram_overlay"
STATE_FILE="/var/run/ramoverlay.state"
DAEMON_PIDFILE="/var/run/ramoverlay-daemon.pid"
LOG_FILE="/var/log/ramoverlay.log"

TMP_SIZE="5G"
VAR_TMP_SIZE="1G"
VAR_CACHE_SIZE="2G"
USER_CACHE_SIZE="2G"

CLEAN_INTERVAL=60
STALE_MINUTES=10

PERSIST_ROOT="/persist"

BIND_MOUNTED_VAR_CACHE=(pacman)
BIND_MOUNTED_USER_CACHE=(paru nvidia mesa_shader_cache mesa_shader_cache_db TauonMusicBox)

# Directories to overlay (will be mounted in RAM and actually used)
# NOTE: Exclude large package/runtime directories to save RAM
OVERLAY_DIRS=(
    "/etc"
    "/var/log"
    # DO NOT OVERLAY THESE - TOO LARGE:
    # "/var/lib"      # Contains flatpak (12GB+), databases, etc.
    # "/opt"          # Can be 2GB+ with large applications
    # "/usr/local"
)

# Directories to completely exclude from overlay
EXCLUDED_FROM_SYNC=(
    "/var/lib/systemd"
    "/var/log/journal"
)

USE_LSOF=0
USE_FUSER=0
if command -v lsof >/dev/null 2>&1; then
    USE_LSOF=1
elif command -v fuser >/dev/null 2>&1; then
    USE_FUSER=1
fi

timestamp() { date +"%Y-%m-%dT%H:%M:%S%z"; }

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        log "ERROR: Must be run as root"
        exit 1
    fi
}

is_active() {
    [ -f "$STATE_FILE" ] && grep -q "active" "$STATE_FILE"
}

is_file_in_use() {
    local file="$1"
    [ -e "$file" ] || return 1
    if [ "$USE_LSOF" -eq 1 ]; then
        $LSOF -t -- "$file" >/dev/null 2>&1 && return 0 || return 1
    elif [ "$USE_FUSER" -eq 1 ]; then
        fuser -s -- "$file" >/dev/null 2>&1 && return 0 || return 1
    else
        local t
        t="$(readlink -f -- "$file")" || return 1
        for fd in /proc/[0-9]*/fd/*; do
            [ -e "$fd" ] || continue
            local link
            link="$(readlink -f -- "$fd" 2>/dev/null)" || continue
            [ "$link" = "$t" ] && return 0
        done
    fi
    return 1
}

mount_tmpfs() {
    local dir="$1" size="$2" mode="$3"
    mkdir -p -- "$dir"
    if mountpoint -q -- "$dir"; then
        log "$dir already mounted, skipping."
        return 0
    fi
    log "Mounting tmpfs on $dir (size=$size mode=$mode)..."
    mount -t tmpfs -o "size=${size},mode=${mode}" none "$dir"
}

bind_persistent_dirs() {
    local parent="$1"
    shift
    local dirs=("$@")
    local persist_root="${PERSIST_ROOT}${parent}"
    mkdir -p "$persist_root" || { log "ERROR: failed to mkdir $persist_root"; return 1; }

    for d in "${dirs[@]}"; do
        local src="$persist_root/$d"
        local dest="$parent/$d"

        if [ -d "$dest" ] && [ ! -e "$src" ]; then
            mkdir -p "$(dirname "$src")"
            if [ "$(ls -A "$dest" 2>/dev/null || true)" != "" ]; then
                log "Moving existing $dest -> $src (first-run persistence)"
                if command -v rsync >/dev/null 2>&1; then
                    $RSYNC -a --remove-source-files "$dest"/ "$src"/ || true
                    $FIND "$dest" -mindepth 1 -type d -empty -delete || true
                else
                    mv "$dest" "$src" || true
                fi
            fi
        fi

        mkdir -p "$src" "$dest"
        
        if ! mountpoint -q "$dest"; then
            mount --bind "$src" "$dest"
            log "Bind-mounted $src -> $dest"
        else
            log "$dest already a mountpoint, skipping bind."
        fi
    done
}

mount_user_caches() {
    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $1 ":" $6 }')
    while IFS=: read -r username homedir; do
        [ -n "$username" ] && [ -n "$homedir" ] || continue
        [ -d "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        local user_stat
        user_stat=$(stat -c "%u:%g" "$homedir" 2>/dev/null) || continue
        local uid=${user_stat%:*}
        local gid=${user_stat#*:}

        if [ ! -d "$cache_dir" ]; then
            mkdir -p "$cache_dir"
            chown "${uid}:${gid}" "$cache_dir"
            chmod 0700 "$cache_dir"
        fi

        if mountpoint -q -- "$cache_dir"; then
            log "$cache_dir already mounted, skipping."
            continue
        fi

        log "Mounting tmpfs on $cache_dir (size=$USER_CACHE_SIZE) for $username..."
        mount -t tmpfs -o "size=${USER_CACHE_SIZE},mode=0700,uid=${uid},gid=${gid}" none "$cache_dir"
        
        bind_persistent_dirs "$cache_dir" "${BIND_MOUNTED_USER_CACHE[@]}"
        
        chown "${uid}:${gid}" "$cache_dir" || true
        for subdir in "${BIND_MOUNTED_USER_CACHE[@]}"; do
            if [ -d "$cache_dir/$subdir" ]; then
                chown -R "${uid}:${gid}" "$cache_dir/$subdir" || true
            fi
        done
    done <<< "$users"
}

umount_try() {
    local dir="$1"
    [ ! -d "$dir" ] && return 0
    if ! mountpoint -q -- "$dir"; then return 0; fi

    log "Attempting normal umount $dir..."
    if umount "$dir" 2>/dev/null; then log "Unmounted $dir (normal)"; return 0; fi
    log "Normal umount failed; trying force..."
    if umount -f "$dir" 2>/dev/null; then log "Unmounted $dir (force)"; return 0; fi
    log "Force umount failed; trying lazy..."
    if umount -l "$dir" 2>/dev/null; then log "Unmounted $dir (lazy)"; return 0; fi
    log "All umount attempts failed for $dir."
    return 1
}

umount_user_caches() {
    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $6 }')
    while read -r homedir; do
        [ -n "$homedir" ] && [ -d "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        for ((i=${#BIND_MOUNTED_USER_CACHE[@]}-1; i>=0; i--)); do
            umount_try "$cache_dir/${BIND_MOUNTED_USER_CACHE[i]}" || true
        done
        umount_try "$cache_dir" || true
    done <<< "$users"
}

umount_var_cache() {
    for ((i=${#BIND_MOUNTED_VAR_CACHE[@]}-1; i>=0; i--)); do
        umount_try "/var/cache/${BIND_MOUNTED_VAR_CACHE[i]}" || true
    done
    umount_try /var/cache || true
}

cleanup_stale_files() {
    local var_cache_excludes=()
    for dir in "${BIND_MOUNTED_VAR_CACHE[@]}"; do
        var_cache_excludes+=("/var/cache/$dir")
    done

    for dir in /tmp /var/tmp; do
        [ -d "$dir" ] || continue
        $FIND "$dir" -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            is_file_in_use "$file" && log "Skipping in-use file: $file" || (rm -rf -- "$file" && log "Removed stale: $file")
        done
    done

    if [ -d /var/cache ]; then
        $FIND /var/cache -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            for ex in "${var_cache_excludes[@]}"; do
                [[ "$file" == "$ex"* ]] && continue 2
            done
            is_file_in_use "$file" && log "Skipping in-use cache file: $file" || (rm -rf -- "$file" && log "Removed stale cache: $file")
        done
    fi

    local users
    users=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $6 }')
    while read -r homedir; do
        [ -n "$homedir" ] || continue
        local cache_dir="$homedir/.cache"
        [ -d "$cache_dir" ] || continue
        $FIND "$cache_dir" -mindepth 1 -mmin +"$STALE_MINUTES" -print0 2>/dev/null | \
        while IFS= read -r -d '' file; do
            for ex in "${BIND_MOUNTED_USER_CACHE[@]}"; do
                [[ "$file" == "$cache_dir/$ex"* ]] && continue 2
            done
            is_file_in_use "$file" && log "Skipping in-use user cache file: $file" || (rm -rf -- "$file" && log "Removed stale user cache: $file")
        done
    done <<< "$users"
}

start_tmpfs_mounts() {
    log "Starting tmpfs mounts for temporary directories..."
    
    mkdir -p "$PERSIST_ROOT"
    
    mount_tmpfs /tmp "$TMP_SIZE" 1777
    mount_tmpfs /var/tmp "$VAR_TMP_SIZE" 1777
    mount_tmpfs /var/cache "$VAR_CACHE_SIZE" 0755

    bind_persistent_dirs /var/cache "${BIND_MOUNTED_VAR_CACHE[@]}"
    mount_user_caches

    getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\/home\// { print $1 ":" $6 }' | \
    while IFS=: read -r username homedir; do
        [ -d "$homedir" ] || continue
        if [ -d "$homedir/.cache" ]; then
            uidgid=$(stat -c "%u:%g" "$homedir")
            chown "$uidgid" "$homedir/.cache" || true
            chmod 0700 "$homedir/.cache" || true
            log "Fixed perms for $homedir/.cache"
        fi
    done
    
    log "tmpfs mounts completed."
}

stop_tmpfs_mounts() {
    log "Stopping tmpfs mounts..."
    log "Syncing filesystem..."
    sync
    
    umount_user_caches
    umount_var_cache
    umount_try /var/tmp || true
    umount_try /tmp || true
    
    log "tmpfs mounts stopped."
}

get_available_ram() {
    local total_kb=$(awk '/MemTotal/ {print int($2 * 0.9)}' /proc/meminfo)
    local total_mb=$((total_kb / 1024))
    echo "${total_mb}M"
}

create_overlay_base() {
    log "Creating RAM overlay base directory..."
    
    local ram_size=$(get_available_ram)
    log "Detected total RAM allocation: $ram_size (90% of total memory)"
    
    mkdir -p "$OVERLAY_BASE"
    
    if ! mountpoint -q "$OVERLAY_BASE"; then
        mount -t tmpfs -o size=$ram_size,mode=0755 tmpfs "$OVERLAY_BASE" || \
            { log "ERROR: Failed to mount tmpfs at $OVERLAY_BASE"; return 1; }
        log "Mounted tmpfs at $OVERLAY_BASE with size $ram_size"
    fi
}

create_directory_overlay() {
    local target_dir="$1"
    local dir_name=$(echo "$target_dir" | tr '/' '_')
    local upper_dir="$OVERLAY_BASE/upper${target_dir}"
    local work_dir="$OVERLAY_BASE/work${target_dir}"
    local backup_dir="$OVERLAY_BASE/backup${target_dir}"
    
    # Create necessary directories
    mkdir -p "$upper_dir" "$work_dir" "$backup_dir"
    
    # Check if already mounted
    if mount | grep -q "overlay on $target_dir type overlay"; then
        log "$target_dir already has overlay mounted, skipping"
        return 0
    fi
    
    # Skip backups to save RAM - overlay tracks changes in upper/ directory
    # Backups are unnecessary since the lower layer remains on disk unchanged
    log "Creating backup directory structure for $target_dir (no data copy to save RAM)..."
    mkdir -p "$backup_dir"
    
    # Create the overlay mount directly over the original directory
    log "Mounting overlay on $target_dir..."
    mount -t overlay overlay_${dir_name} \
        -o lowerdir=$target_dir,upperdir=$upper_dir,workdir=$work_dir \
        "$target_dir" || {
            log "ERROR: Failed to mount overlay on $target_dir"
            return 1
        }
    
    log "Successfully mounted RAM overlay on $target_dir"
    return 0
}

start_overlay() {
    if is_active; then
        log "RAM overlay is already active"
        return 0
    fi
    
    log "Starting unified RAM overlay system..."
    
    start_tmpfs_mounts
    create_overlay_base
    
    # Mount overlays on each specified directory
    local failed=0
    for dir in "${OVERLAY_DIRS[@]}"; do
        if [ -d "$dir" ]; then
            create_directory_overlay "$dir" || {
                log "WARNING: Failed to create overlay for $dir"
                failed=$((failed + 1))
            }
        else
            log "WARNING: Directory $dir does not exist, skipping"
        fi
    done
    
    if [ $failed -gt 0 ]; then
        log "WARNING: $failed overlay(s) failed to mount"
    fi
    
    echo "active" > "$STATE_FILE"
    echo "started=$(date +%s)" >> "$STATE_FILE"
    
    log "RAM overlay system started successfully"
    log "Overlaid directories: ${OVERLAY_DIRS[*]}"
    log "Changes are being stored in RAM at: $OVERLAY_BASE"
    
    df -h "$OVERLAY_BASE" 2>/dev/null | tail -1 | awk '{print "RAM allocated: " $2 " (Used: " $3 ", Available: " $4 ")"}'
    
    log "tmpfs cleanup loop starting (interval=${CLEAN_INTERVAL}s, stale>${STALE_MINUTES}m)."
    
    # Show what's actually overlaid
    log "Active overlay mounts:"
    mount | grep "type overlay" | tee -a "$LOG_FILE"
}

sync_changes() {
    if ! is_active; then
        log "RAM overlay is not active, nothing to sync"
        return 0
    fi
    
    log "Syncing changes from RAM to disk..."
    
    local sync_failed=0
    
    for dir in "${OVERLAY_DIRS[@]}"; do
        local upper_dir="$OVERLAY_BASE/upper${dir}"
        
        if [ ! -d "$upper_dir" ]; then
            log "No changes in $dir, skipping"
            continue
        fi
        
        # Check if there are any changes
        if [ -z "$(ls -A "$upper_dir" 2>/dev/null)" ]; then
            log "No changes in $dir, skipping"
            continue
        fi
        
        log "Syncing changes from $dir..."
        
        # Build exclude list
        local exclude_opts=()
        for excl in "${EXCLUDED_FROM_SYNC[@]}"; do
            if [[ "$excl" == "$dir"* ]]; then
                exclude_opts+=("--exclude=${excl#$dir/}")
            fi
        done
        
        # Sync changes directly from upper layer to disk
        log "Syncing $dir from overlay to disk..."
        # Sync directly from upper layer (changes) to the lower layer (disk)
        # We need to temporarily unmount the overlay to write to the real directory
        if $RSYNC -aAXHv "${exclude_opts[@]}" \
            "$upper_dir/" "$dir/" 2>&1 | tee -a "$LOG_FILE"; then
            log "Successfully synced $dir"
        else
            log "ERROR: Failed to sync $dir (rsync exit code: $?)"
            sync_failed=$((sync_failed + 1))
        fi
    done
    
    sync
    
    if [ $sync_failed -gt 0 ]; then
        log "WARNING: $sync_failed directory sync(s) failed"
        return 1
    else
        log "All changes synced successfully"
        return 0
    fi
}

stop_overlay() {
    if ! is_active; then
        log "RAM overlay is not active"
        stop_tmpfs_mounts
        return 0
    fi
    
    log "Stopping RAM overlay system..."
    
    # Sync changes first
    sync_changes
    
    # Unmount overlays in reverse order
    log "Unmounting overlay filesystems..."
    for ((i=${#OVERLAY_DIRS[@]}-1; i>=0; i--)); do
        local dir="${OVERLAY_DIRS[i]}"
        if mount | grep -q "overlay.*on $dir type overlay"; then
            log "Unmounting overlay on $dir..."
            
            # Try to copy changes to the real directory before unmounting
            local upper_dir="$OVERLAY_BASE/upper${dir}"
            local backup_dir="$OVERLAY_BASE/backup${dir}"
            
            if [ -d "$upper_dir" ] && [ -n "$(ls -A "$upper_dir" 2>/dev/null)" ]; then
                log "Final sync of $dir before unmount..."
                
                # Unmount the overlay first
                if umount_try "$dir"; then
                    # Sync changes directly from upper layer to real directory
                    log "Syncing changes from overlay to disk for $dir..."
                    $RSYNC -aAXH "$upper_dir/" "$dir/" 2>&1 | tee -a "$LOG_FILE" || {
                        log "ERROR: Failed final sync of $dir"
                    }
                else
                    log "ERROR: Failed to unmount $dir"
                fi
            else
                umount_try "$dir" || true
            fi
        fi
    done
    
    # Unmount the overlay base
    if mountpoint -q "$OVERLAY_BASE"; then
        log "Unmounting tmpfs and freeing RAM..."
        umount "$OVERLAY_BASE" || log "Warning: Failed to unmount tmpfs"
    fi
    
    rm -f "$STATE_FILE"
    
    stop_tmpfs_mounts
    
    log "RAM overlay system stopped - RAM freed"
}

get_logged_in_users() {
    # More reliable user detection
    local count=0
    
    # Check who command
    count=$(who | awk '{print $1}' | sort -u | wc -l)
    
    # If no users from who, check for X sessions
    if [ $count -eq 0 ] && [ -d /tmp/.X11-unix ]; then
        count=$(ls -1 /tmp/.X11-unix/ 2>/dev/null | wc -l)
    fi
    
    echo $count
}

wait_for_login() {
    log "Waiting for user login..."
    
    while true; do
        local users=$(get_logged_in_users)
        
        if [ "$users" -gt 0 ]; then
            log "User login detected ($users users)"
            return 0
        fi
        
        sleep 5
    done
}

shutdown_cleanup() {
    log "Shutdown/reboot signal received - syncing all changes to disk..."
    sync_changes
    stop_overlay
    rm -f "$DAEMON_PIDFILE"
    log "Shutdown sync complete - exiting"
    exit 0
}

check_root

if [ -f "$DAEMON_PIDFILE" ] && kill -0 $(cat "$DAEMON_PIDFILE") 2>/dev/null; then
    log "Already running with PID $(cat $DAEMON_PIDFILE) - exiting"
    exit 0
fi

echo $$ > "$DAEMON_PIDFILE"

mkdir -p "$(dirname "$LOG_FILE")"
touch "$LOG_FILE" || true

log "Unified RAM overlay daemon started (PID: $$)"
log "Overlay directories: ${OVERLAY_DIRS[*]}"
[ "$USE_LSOF" -eq 1 ] && log "Using lsof to detect open files" || log "Using fuser or /proc fallback for file detection"

trap shutdown_cleanup SIGTERM SIGINT SIGHUP

while true; do
    wait_for_login
    
    sleep 3
    
    log "Starting RAM overlay system..."
    start_overlay
    
    if [ $? -eq 0 ]; then
        log "RAM overlay started successfully"
        log "System is now running with RAM-backed directories"
        log "Check 'mount | grep overlay' to see active overlays"
    else
        log "ERROR: Failed to start RAM overlay - will retry on next login"
        sleep 5
        continue
    fi
    
    while [ $(get_logged_in_users) -gt 0 ]; do
        sleep "$CLEAN_INTERVAL"
        cleanup_stale_files
    done
    
    log "All users logged out - initiating shutdown sequence"
    
    sleep 2
    
    log "Stopping and syncing RAM overlay..."
    stop_overlay
    
    if [ $? -eq 0 ]; then
        log "RAM overlay stopped and synced successfully"
    else
        log "ERROR: Issues during RAM overlay shutdown"
    fi
    
    log "System ready for next login cycle"
    
    sleep 5
done
